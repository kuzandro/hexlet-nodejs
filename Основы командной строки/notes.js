Командная оболочка — программа, через которую происходит управление операционной системой и установленными программами, используя командную строку. 
shell ("шелл"), командная оболочка и командный процессор
Командная оболочка и терминал — не одно и тоже. Терминал — это программа, которая запускает командную оболочку внутри себя.
Командную оболочку нередко называют реплом (REPL, Read-Eval-Print-Loop), что отражается в способе взаимодействия с пользователем:

Read — шелл ждёт ввода команды от пользователя
Eval — шелл исполняет введённую команду
Print — шелл выводит результат
Loop — возвращаемся к первому пункту

Домашняя работа 1:
echo $PWD
// BEGIN (write your solution here)
/usr/src/app
// END

после загрузки системы мы попадаем в режим ожидания ввода команды. 
Этот режим привязан к файловой системе. 
Мы всегда находимся внутри какой-то директории, которую называют "рабочей", working directory. 
Проверяется текущая директория командой pwd "print working directory"

$ pwd
/Users/guest

В начале нет диска, но есть единый корневой каталог /. 
Это вершина файловой системы, все остальные файлы и директории лежат внутри этого корня.

ls — программа, которая выводит список файлов и директорий в рабочей (текущей) директории.

$ ls
Desktop  Documents Downloads Library  Movies  Music  Pictures Public

cd (change directory), с помощью неё осуществляется перемещение по файловой структуре

$ cd Music
# Смотрим ее содержимое
 Music$ ls
iTunes
# Смотрим текущую рабочую директорию
 Music$ pwd
/Users/guest/Music

Абсолютный путь — это полный путь начиная от корня, в нашем случае /, 
а относительный — это путь, начинающийся от нашей текущей рабочей директории.

<не важно в каком месте>$ cd /Users/guest/Music # Абсолютный путь

достаточно указать специальное значение .. и произойдёт переход на директорию, уровнем выше

 Music$ cd ..
$ pwd
/Users/guest

# Выход на два уровня вверх
 Music$ cd ../..
$ pwd
/Users

иногда используется одинарная точка, означающая текущую директорию. Например, вместо cd Music, можно писать cd ./Music. Оба эти выражения эквивалентны. 

 Music$ cd
$
команда cd, выполненная без аргументов, перебрасывает в домашную директорию текущего пользователя

Домашняя директория пользователя имеет специальное обозначение — ~ (тильда), которое в момент выполнения команды заменяется на абсолютный путь. 
Поэтому из любого места можно сделать прямой переход в любую поддиректорию домашней директории.

 <из любого места>$ cd ~/Music
  Music$ pwd
/Users/guest/Music

Шел облегчает жизнь и предлагает автозавершение имён. Автокомплит выполняется двойным нажатием на клавишу Tab

Домашняя работа 2:
поиск файла

bash-4.4$ cd /opt
bash-4.4$ ls
follow
bash-4.4$ cd follow
bash-4.4$ ls
find  me
bash-4.4$ cd find
bash-4.4$ ls
lala
bash-4.4$ cd lala
bash-4.4$ ls
empty
bash-4.4$ cd empty
bash-4.4$ ls
bash-4.4$ cd /opt
bash-4.4$ ls
follow
bash-4.4$ cd follow
bash-4.4$ cd me
bash-4.4$ ls
some  touch
bash-4.4$ cd touch
bash-4.4$ ls
bash-4.4$ cd ..
bash-4.4$ cd some
bash-4.4$ ls
non  pop
bash-4.4$ cd pop
bash-4.4$ ls
bash-4.4$ cd ..
bash-4.4$ cd non
bash-4.4$ ls
i-got-it
bash-4.4$ cd i-got-it
bash: cd: i-got-it: Not a directory
bash-4.4$ 

ls -a вывод скрытых файлов

$ ls -a
.  .CFUserTextEncoding Desktop   Downloads Movies Pictures
.. .localized          Documents Library   Music  Public

У команд бывают аргументы и опции (их также называют флагами). 
Например, в команде ls Music, Music — это аргумент, а вот в команде ls -a, -a — это опция. 
Опции всегда начинаются с одного или двух дефисов.

-l выводит дополнительную информацию

$ ls -l
total 0
drwx------+  3 Guest  _guest   96 Nov 21  2017 Desktop
drwx------+  3 Guest  _guest   96 Nov 21  2017 Documents
drwx------+  3 Guest  _guest   96 Nov 21  2017 Downloads
drwx------+ 26 Guest  _guest  832 Nov 21  2017 Library
drwx------+  3 Guest  _guest   96 Nov 21  2017 Movies
drwx------+  3 Guest  _guest   96 Nov 21  2017 Music
drwx------+  3 Guest  _guest   96 Nov 21  2017 Pictures
drwxr-xr-x+  4 Guest  _guest  128 Nov 21  2017 Public

Комбинация опций
ls -a -l 
ls -al
ls -la

Использование и опций, и аргументов
ls -la Music

Документация man <имя команды>
Для выхода из режима просмотра q, для просмотра вперёд f (forward), назад — b (backward)
"https://explainshell.com/" интерактивное описание
Большинство утилит имеет две версии одной и той же опции:
одна из них длинная, другая — короткая. Например -v и --version в PHP
короткие для быстроты, длинные - чтоб скрипты были понятными

# Вместо -o можно написать --output-file
$ say -o hi.aac 'Hello, World.'
Опции с параметрами 
Если значение опции содержит в себе специальные или пробельные символы, то его нужно оборачивать в кавычки, двойные или одинарные - не важно.
$ say -o 'hi.aac' 'Hello, World.'


say [-v voice] [-r rate] [-o outfile [audio format options] | -n name:port | -a device] [-f file | string ...]
Описания построены по одному и тому же принципу. 
Квадратные скобки обозначают опциональность []. 
Например, опция -v опциональна, то же самое касается и любых других опций этой программы. 
Вертикальная черта | обозначает исключающее "или". 
[-f file | string ...]. 
это строка значит, что say может либо произносить текст из файла, либо произносить строчку, 
переданную как аргумент, но не то и другое одновременно. 
Другие вариации описания способов вызова: 
значение по умолчанию, выбор из конкретных элементов, отрицание.

Домашняя работа 3:
Вывод файлов в полном виде, сортировка по размеру
ls -lS --time-style 'long-iso' /var

Файловая система nix систем
Файловая структура представляет собой дерево, в узлах которого находятся директории, а в листьях — файлы.
Используют слово директория вместо слова папка
В Windows несколько деревьев - несколько дисков
В никс все лежит в корне / 

Информация о любом файле или директории доступна по команде stat
В Windows и Mac имена файлов регистронезависимы
В никс index.html Index.html - разные файлы
в *nix "всё есть файл"
Директория — это специальный файл, 
который содержит список файлов. 
Любое подключаемое устройство становится файлом или директорией, если это накопитель.

В *nix системах есть базовый набор каталогов, который стандартизирован (FHS)
/etc содержит конфигурацию программ в обычных текстовых файлах
/home содержит домашние директории пользователей системы и тд 
"https://ru.wikipedia.org/wiki/FHS" подробнее

В отличие от Windows, в *nix системах отсутствует понятие "расширение файла". 
Точка — полноправная часть имени. Нередко встречаются и такие имена index.html.haml

В *nix также есть скрытые файлы, но, в отличие от Windows, это не свойство файла, 
а определённое имя файла. 
Все файлы и директории, начинающиеся с точки, считаются скрытыми. 
Вывести все файлы, включая скрытые, можно командой ls -a
особые директории, обозначенные "точкой" (.) и "двумя точками" (..). 
Точка означает текущую директорию, а две точки — директорию верхнего уровня.

Кроме регулярных файлов, в *nix существует ряд других:
Hard Link — дополнительное имя для уже существующего файла.
Symbolic link — символическая ссылка, такой файл похож на ярлык в Windows. 
Если удалить основной файл, то символическая ссылка начнёт вести в никуда.
Socket — специальный файл через который происходит взаимодействие между разными процессами операционной системы.

Чтение текстовых файлов
Самый простой способ прочитать файл — команда cat.
cat ожидает аргументы — пути до файлов, которые надо читать.
$ cat .bash_logout

Иногда бывает нужно посмотреть только начало файла или его конец, 
в такой ситуации помогают команды head и tail. 
head показывает первые 10 строк, а tail — последние 10 строк файла. 
желаемое количество строк через опцию -n
$ head -n 2 .bashrc
$ tail -n 2 .bashrc

tail -f path/to/file не просто выводит последние строчки файла, но ждёт появления новых. 
удобно для чтения логов
В Linux логи лежат в каталоге /var/log. 
Туда пишет как сам Linux, так и большая часть установленных программ.
Основной файл логов Linux называется syslog. 

Пейджер похож на текстовый редактор, но открытый только в режиме чтения. 
Самый распространённый пейджер называется less.
less открывает файл и остаётся в этом режиме. 
Он позволяет перемещаться по файлу вперёд и назад, производить поиск. 
они одинаково хорошо и быстро работают с файлами любых размеров. 
пейджер не пытается загрузить в память весь файл до его отображения. 
Он грузит только ту часть, которая помещается на экран 
и при перемещении подгружает остальное.

Основные якори less
q — выход
f — вперёд на страницу
b — назад на страницу
если набрать /, затем начать вводить буквы и нажать Enter, 
то выполнится поиск введённого текста. 
Перемещение по найденным совпадениям выполняется командой n 
(переход к следующему совпадению) и командой N (переход к предыдущему совпадению).

Домашняя работа 4:
Прочитать первые 3 строки файла
head -n 3 /home/tirion/.bashrc

Grep поиск по файлу
$ man grep

SYNOPSIS
       grep [OPTIONS] PATTERN [FILE...]
       grep [OPTIONS] [-e PATTERN]...  [-f FILE]...  [FILE...]

PATTERN — это то, что ищется, необязательно конкретная строчка, 
возможно определённый шаблон (см. регулярные выражения). 
FILE — путь до файла, в котором нужно искать
Найденные строчки выводятся на экран в том же порядке, в котором они встречаются в исходном файле.
-B, --before-context число отображаемых слов до вхождения
-A, --after-context после вхождения
-C, --context с двух сторон

Иногда мы не знаем, в каком файле то, что мы ищем, но знаем директорию, 
в которой лежит этот файл. В такой ситуации нужно сделать два изменения:
- Добавить опцию -R, которая говорит о том, что надо искать внутри директории 
(рекурсивно, то есть включая все поддиректории).
- Указать путь до директории, а не файла.
$ grep -R bashrc .

При таком поиске в выводе указывается файл, в котором была найдена строка. 
Если добавить опцию n, то дополнительно отобразится номер строки.

$ grep -Rn bashrc .
./.profile:13:    # include .bashrc if it exists
./.profile:14:    if [ -f "$HOME/.bashrc" ]; then
./.profile:15:  . "$HOME/.bashrc"

Домашняя работа 5:
Грепните файл /home/tirion/.bashrc по строчке then. Результат добавьте в solution.
grep then /home/tirion/.bashrc

Текстовые редакторы
Nano - маленький и простой
Символ ^ означает клавишу Ctrl. 
Например, для выхода из редактора нужно набрать Ctrl + x, 
а затем либо подтвердить сохранение изменений, либо отвергнуть, нажав y (yes) или n (no).

Vim
Ключевое отличие - наличие режимов
Вим, после открытия, работает в режиме команд (COMMAND): 
нажатие на любую клавишу воспринимается как сигнал к какому-то действию. 
Если вы не знаете команд, то лучше ничего не трогать, иначе на экране начнётся хаос.

Обычное редактирование текста выполняется в режиме ввода (INSERT) 
и попасть в него можно нажав клавишу i

Для выхода в режим команд достаточно нажать Esc (или комбинацию Ctrl + [).

Вим по праву считается редактором с самым высоким порогом входа.
Но его многие используют для разработки.
"http://guides.hexlet.io/vim" гайд по виму

самое сложное в виме — это выйти
Убедитесь, что вы находитесь в командном режиме, 
на всякий случай нажмите Esc (или комбинацию Ctrl + [)
Затем наберите :, эта команда переведёт вас в режим командной строки (еще один режим)
ввесьт q! и нажать Enter Так вы выйдите из вима без сохранения изменений
Если набрать :wq, то перед выходом сохранятся все изменения. 
Если вы хотите просто сохраниться без выхода, то наберите :w

В Vim есть четыре основных режима работы:

Командный режим (обычный режим) — это режим по умолчанию. 
Перемещение по файлу, быстрое (при помощи команд, комбинаций клавиш) редактирование, 
удаление, поиск текста.

Режим вставки (режим ввод) — ввод текста с клавиатуры. 
То, как вы привыкли это делать в обычных редакторах.

Визуальный режим — выделение произвольных участков текста.

Режим командной строки — собственная командная строка для редактора текста, 
из которой можно выполнять великое множество разнообразных команд.

Потоки
 При старте любой программы операционная система связывает с ней три так называемых потока: STDIN, STDOUT и STDERR.
Язык программирования взаимодействует с ними как  файлами
печать на экран -> вывод с stout -> операционная система выводит куда надо

ОС может менять потоки
$ ls -la > output
называется перенаправление потоков. 
Символ > означает, что нужно взять вывод из команды, указанной слева, и отправить его в файл, указанный справа. 
> всегда перезаписывает файл. 
Такое перенаправление работает с абсолютно любой командой, которая выводит результаты своей работы на экран.

$ grep alias .bash_profile > result
$ cat result
alias fixssh='eval $(tmux showenv -s SSH_AUTH_SOCK)'

Если нужно не перезаписывать, а добавлять, то используйте >>.

echo принимает на вход строчку и выдаёт её в STDOUT, который уже можно перенаправлять.
# > перетирает файл
$ echo 'hello' > result
$ cat result
hello
$ echo 'hello' > result
$ cat result
hello
# >> добавляет содержимое в конец файла
$ echo 'hello' >> result
$ cat result
hello
hello
$

STDIN (стандартный ввод) и STDERR (вывод ошибок)
утилита wc умеет считать количество слов, строк или символов в файле.
Когда мы говорим о файле, то в *nix это почти всегда означает, что данные можно передать и в стандартный поток ввода.

# Флаг l (l а не 1) говорит о том, что надо считать количество строк
$ wc -l < result
2

перенаправление ввода и вывода.

$ wc -l < result > output
$ cat output
$ 2

STDERR, как и STDOUT, по умолчанию идёт на экран. 
STDERR позволяет отделить нормальный вывод программы от возникающих ошибок. 
Такой подход удобен при ведении логов, для реагирования и отладки. 
Будьте осторожны, перенаправление вывода в файл перенаправляет только STDOUT.
Решить эту задачу можно двумя способами. Перенаправив STDERR в STDOUT, либо отправив их оба в файл.

# Сначала STDERR перенаправляется в STDOUT, затем STDOUT в файл
$ cd lala > output 2>&1
$ cat output
-bash: cd: lala: No such file or directory

2 - в данном случае обозначает номер потока. 
В POSIX, за каждым потоком закреплен определенный номер, 
который является файловым дескриптором если быть точным: STDIN — 0, STDOUT — 1, STDERR — 2. 
Конструкцию 2>&1 нужно просто запомнить, она говорит о том, что поток с номером 2 отправляем в поток с номером 1

Перенаправление STDERR бывает полезно само по себе, без вывода в файл.

#  STDERR просто перенаправляется в другой поток (STDOUT)
$ cd lala 2>&1
-bash: cd: lala: No such file or directory
Перенаправление обоих потоков в файл

# Сначала STDERR перенаправляется в STDOUT, затем STDOUT в файл
$ cd lala &> output
$ cat output
-bash: cd: lala: No such file or directory

Домашняя работа 6:
Прочитайте в командной строке содержимое файла source и перенаправьте его в файл solution (которого не существует).
bash-4.4$ cat source > ./solution

pipeline (конвейер) - подход соединения входов одного и выходов другого процессов
| — этот символ называется пайп, он указывает шелу взять STDOUT одного процесса и соединяет его с STDIN другого процесса. 
Запись grep alias .bashrc | grep color можно изменить, используя перенаправление. Так она станет проще для модификации:

$ cat .bashrc | grep alias | grep color
cat source | grep Dog | uniq | sort
Читается файл source
Входные данные грепаются по подстроке "Dog"
Убираются дубли (в исходном файле две одинаковых строки "Dog")
Входные данные сортируются и выводятся на экран

Пайплайн стал основой Unix философии, которая звучит так:
Пишите программы, которые делают что-то одно и делают это хорошо.
Пишите программы, которые бы работали вместе.
Пишите программы, которые бы поддерживали текстовые потоки, поскольку это универсальный интерфейс.

Домашняя работа 7:
Посредством конвейера отсортируйте содержимое файла languages, выберите две первых строчки и запишите их в файл solution.
bash-4.4$ sort languages | head -n 2 > ./solution

возможность модифицировать файловую структуру завязана на права пользователя.
в домашней можно все модифицировать

Для создания файлов принято использовать утилиту touch.
основная задача - изменить время последнего доступа , но она создает файл если его нет
# В текущей директории создаётся пустой файл
touch empty-file

Удаляется файл командой rm:
rm empty-file

В *nix системах не существует понятия "переименовать файл". Переименование всегда равносильно перемещению, которое выполняется командой mv
touch file
mv file renamed-file

Для копирования файлов и директорий используется утилита cp (copy). Её первый аргумент — имя источника (откуда), второй — имя приёмника (куда).
cp renamed-file renamed-file-copy

Для копирования директории нужно добавить флаг -r (recursive).
Все эти и последующие утилиты работают с файлами и директориями, расположенными в любом месте файловой системы. Поэтому вы всегда можете передать любой путь: touch /tmp/tempfile.
Утилиты для работы с директориями частично отличаются. Создание директории выполняется командой mkdir.
mkdir my-dir

По умолчанию эта команда не создаёт вложенных директорий:
mkdir one/two/three
mkdir: cannot create directory ‘one/two/three’: No such file or directory

В такой ситуации придётся либо создавать каждую директорию отдельно, либо воспользоваться флагом -p, который создаёт директории рекурсивно.
mkdir -p one/two/three

Удаление директорий выполняется той же командой, что и удаление файлов, но без флагов оно выдаёт предупреждение:
rm my-dir/
rm: cannot remove 'my-dir/': Is a directory

Чтобы не было ошибки, нужно добавить флаг -r. Он включает режим рекурсивного (r - recursion) удаления содержимого директорий, 
то есть идет просмотр всего что внутри во всех вложенных директориях и поддиректориях (до самого конца).
rm -r my-dir

Если внутри директории есть файлы, то команда rm начнёт задавать вопрос по каждому из них, нужно ли его удалять. 
Если вы точно уверены, что удалить нужно всё, добавьте флаг -f. В таком случае rm удалит всю директорию без вопросов.
rm -rf one

Домашная работа 8:
создать файловую структуру

bash-4.3$ ls
ansible.cfg  fs  inventory.ini  Makefile  playbook.yml
bash-4.3$ cd fs
bash-4.3$ mkdir example1
bash-4.3$ ls
example1
bash-4.3$ mkdir example2
bash-4.3$ cd example2
bash-4.3$ touch another_file
bash-4.3$ cd ..
bash-4.3$ ls
example1  example2
bash-4.3$ touch example1/file
bash-4.3$ mkdir example1/subexample
bash-4.3$ mkdir example1/subexample/folder
bash-4.3$ touch example1/subexample/folder/another_file
bash-4.3$ touch example1/subexample/file

Переменные окружения похожи на переменные в языках программирования. 
Они существуют в рамках запущенной сессии командного интерпретатора, подгружаются туда во время его инициализации (но это не единственный путь их появления). 
Посмотреть установленные переменные можно командой env.

Основное предназначение переменных окружения — конфигурация системы и программ.
Существует некоторый базовый набор переменных, которые всегда устанавливаются башем при старте. 
По умолчанию, любой запущенный процесс получает все переменные родительского процесса (процесс-создатель). 
Именно поэтому команда cd может прочитать переменную HOME. 
Переменные можно создавать и изменять в любой момент времени, например:

# Для вывода переменной используется echo, а перед самой переменной ставится знак $.
$ echo $HOME
/home/kirill.m
# Для установки знак $ не нужен.
# Очень важно чтобы не было пробелов вокруг знака равно
$ HOME=/tmp

Попробуем установить HOME и выполнить переход.
# Достаточно выполнить присваивание слева от запускаемой команды
$ HOME=/tmp cd
/tmp$ pwd
/tmp
Ничего не подозревающая команда cd получила переменную HOME и выполнила честный переход в указанную директорию. Теперь снова сделаем cd, но уже не указывая ничего.
$ cd
~$ pwd
/home/kirill.m
~$ echo $HOME
/home/kirill.m
В этот раз произошел переход в настоящую домашнюю директорию. Получается, что вызов выше изменил переменную только для того конкретного запуска.
Существует два способа задавать значение переменной окружения: локальный и глобальный. 

Другой способ установки изменяет значение глобально, для всей сессии и выполняется так:

~$ export HOME=/tmp
/home/kirill.m$ cd
~$ pwd
/tmp
~$ echo $HOME
/tmp
Обратите внимание на то, что изменение происходит в рамках текущей сессии, 
другими словами, если у вас открыто две вкладки терминала, и в каждой загружен баш, 
то изменение произойдет только в той вкладке, в которой будет выполнена команда.

Самый простой способ просматривать историю команд — нажимать клавиши "вверх/вниз"
История команд баша хранится в специальном файле .bash_history, который лежит в домашней директории пользователя
За то, какое количество команд хранится в истории, отвечает переменная окружения HISTFILESIZE. 
Если она выставлена, то берётся указанное в ней число, иначе история не обрезается и файл .bash_history растёт "бесконечно"

$ history
    1  docke rps
    2  free -m
    3  docker ps
    4  docker exec -it 8678a6520641 bash
    5  ls
    6  exit
    7  docker ps
    8  docker exec -it 1209b6e5ce6b bash
    ...

Если набрать history 5, то отобразятся только 5 последних введённых команд. 

$ !2
# Эта команда имела второй номер в листинге выше
free -m
              total        used        free      shared  buff/cache   available
Mem:           1998        1532          75          21         390         227
Swap:             0           0           0

При необходимости историю всегда можно погрепать:

$ history | grep export
  174  export HOME=/tmp
  183  history | grep export

/Реверсивный поиск. 
Если нажать комбинацию Ctrl + r, то запустится специальный поиск по истории. 
Он ожидает ввода символов и сразу отображает ближайшую команду, в которой эти символы встречаются. 
Если найденное соответствие вас не устроило, то повторное нажатие Ctrl + r выберет следующее соответствие из истории.

Права и пользователи
$ whoami
kirill.m

позволяет выяснить активного пользователя
Абсолютно любой процесс, запускаемый в операционной системе, стартует от имени некоторого пользователя. 
присутствие пользователя для запуска необязательно. 
Да, работая в командной строке мы стартуем всё сами, 
но когда система загружается, то она стартует множество различных процессов и 
для многих из них создаются собственные пользователи с ограниченным набором прав.

Информацию о том, какой процесс и под каким пользователем запущен, можно получить из вывода ps aux:

$ ps aux
# Левый столбец имя пользователя
root      7717  0.0  0.0   4244  1504 ?        S    10:52   0:00 mpstat 1 3
kirill.m  7718  0.0  0.1  36084  3236 pts/0    R+   10:52   0:00 ps aux
alexand+ 10542  0.0  0.1  21500  2892 pts/1    Ss+  10:10   0:00 -bash

запуская, например, touch, мы стартуем процесс от своего имени, внутри которого запускается программа touch. 
Она, в свою очередь, создаёт файл (если его не было) и делает вас владельцем нового файла. 
Кстати, модификация существующих файлов не влияет на владельца — для его смены нужно воспользоваться специальной утилитой. 
В домашней директории пользователя всё принадлежит пользователю

$ ls -la
total 44
drwxr-xr-x 5 kirill.m kirill.m 4096 Aug 29 11:34 .
drwxr-xr-x 8 root     root     4096 Apr 26 10:38 ..

Третий столбец в этом выводе — как раз владелец.
Единственная запись, которая выбивается из всего списка это .., то есть родительская директория. Её владельцем является root
Каждый каталог в директории /home является домашним каталогом конкретного пользователя. 
Поэтому они все имеют разных владельцев, как правило, совпадающих с именем директории.

Имя пользователя в системе должно быть уникальным, но его можно менять.
имя пользователя связано с идентификатором, называемым UID. 
Это число, которое и определяет пользователя. 
Если поменяется имя пользователя, но идентификатор останется прежним, то все доступы останутся. 
Если же сменится идентификатор, то фактически сменится и пользователь. 
Соответственно, новый пользователь потеряет доступы ко всему старому. 
Посмотреть id:
с помощью команды id:

$ id
uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)

второй способ
$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin

Запись /usr/sbin/nologin говорит о том, что данный пользователь не может входить в систему. 
Такие пользователи нужны для запуска программ, имеющих ограниченные права, и им, естественно, не нужно входить в систему.

Кроме имени, у пользователей *nix систем есть связанное с ним понятие группа. 
Группа, как можно догадаться из названия, создана для группового доступа к разделяемому (общему) ресурсу (например, файлу). 
Например, у нас есть группа разработчиков, которые регулярно ходят на сервер, и им нужно дать одинаковые возможности по управлению определёнными файлами. 
Так как владелец у файла ровно один, то мы не можем решить этот вопрос через смену владельца, но можем через создание группы. 
Достаточно её создать и привязать к самому пользователю. Группы, ассоциированные с текущим пользователем, показываются в выводе команды id:
$ id
uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)

Здесь группа kirill.m является основной, такая группа может быть только одна, и именно в эту группу входят любые создаваемые файлы от имени текущего пользователя. 
Кроме основной, пользователь может входить в произвольное число дополнительных групп.

В любой *nix системе присутствует специальный пользователь root, или, как говорят, суперпользователь. 
Главная его особенность — это идентификатор со значением 0 (а имя в теории можно поменять). 
Этот пользователь имеет особое значение для системы и может выполнять абсолютно любые действия в системе.

Крайне не рекомендуется использовать этого пользователя на регулярной основе. 
И ни в коем случае нельзя входить под ним в систему. root — это прямой доступ ко всему и большая дыра в безопасности системы. 
Кроме того, систему очень легко убить, например, удалив случайно не тот файл или испортив важную конфигурацию, после чего вход в систему станет невозможным.
Несмотря на это, root нужен для выполнения некоторых привилегированных действий, которые недоступны обычным пользователям.

Ситуаций, в которых необходимо повышать привилегии и выполнять команды от рута (пользователя root), довольно много.
Установка новых программ
Навигация по чужим директориям
Изменение прав доступа и владельцев файлов, не принадлежащих текущему пользователю
Создание, редактирование и удаление файлов в местах, где не хватает прав текущего пользователя
Запуск программ, требующих повышенные привилегии

Стать другим пользователем, находясь прямо в системе, можно с помощью утилиты su (switch user).
Основной способ повышать привилегии в современных системах — утилита sudo.
# Нет прав на выполнение
$ touch /etc/myfile
touch: cannot touch '/etc/myfile': Permission denied

# С sudo все работает
$ sudo touch /etc/myfile

# Видно что владелец файла root
$ stat /etc/myfile
  File: '/etc/myfile'
  Size: 0           Blocks: 0          IO Block: 4096   regular empty file
Device: ca01h/51713d    Inode: 2761        Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)

# Нет прав на удаление
$ rm /etc/myfile
rm: remove write-protected regular empty file '/etc/myfile'? y
rm: cannot remove '/etc/myfile': Permission denied

# Опять помогло sudo
$ sudo rm /etc/myfile
$

В зависимости от настроек sudo в системе, эта утилита может попросить ваш пароль для входа, 
либо вообще откажется работать, сказав, что у вас нет права её использовать.

Иногда бывает нужно выполнить команду из под пользователя, отличного от root. Тогда придётся добавить флаг -u:

$ sudo -u nobody mkdir /tmp/test
# Файл создан от nobody
$ stat /tmp/test
  File: '/tmp/test'
  Size: 4096        Blocks: 8          IO Block: 4096   directory
Device: ca01h/51713d    Inode: 4577        Links: 2
Access: (0755/drwxr-xr-x)  Uid: (65534/  nobody)   Gid: (65534/ nogroup)

Если стоит задача произвести сразу пачку действий от имени другого пользователя, то для этого можно запустить новую сессию поверх текущей:

$ sudo -i
$ id
uid=0(root) gid=0(root) groups=0(root)
Главное — не забыть переключиться обратно после завершения необходимых манипуляций. Для этого наберите exit.

Частая ошибка, с которой встречаются разработчики — ошибка доступа:

$ touch /etc/myfile
touch: cannot touch '/etc/myfile': Permission denied

Она говорит о том, что текущий пользователь не имеет прав на создание файлов в каталоге /etc. 

Кроме имени пользователя и группы, с каждым файлом ассоциированы права доступа: r — чтение, w — запись и x — исполнение. 
Причём, эти права задаются для трёх типов пользователей: владельца (Owner), пользователей, входящих в ту же группу (Group) и остальных (Other) — 

# Пример строчки из вывода команды ls -la
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc
Запись слева представляет из себя один из вариантов описания прав доступа (permissions). 
Для удобства чтения разделим эту запись на группы символов - rw- r-- r--. 
Символ - в этой записи говорит о том, что перед нами обычный файл. 
За ним следует три группы, в каждой из которых по три символа. 
Каждая группа описывает доступы для разных типов пользователей. 
Первая описывает права доступа для владельца файла. 
rw- означает, что владелец этого файла может как читать (r) этот файл, так и писать (w) в него. 
Последний прочерк означает, что этот файл нельзя исполнять. 
Исполнение описывается символом x 
Не важно, какой файл или директорию мы смотрим — порядок прав в этой группе всегда один и тот же чтение-запись-исполнение, а прочерк означает отсутствие данного права.

Следующая группа прав относится к тем, кто входит в группу kirill.m
То же самое касается и тех, кто не входит в эту группу, то есть набор прав у последних двух одинаковый.
Удалить файл можно только, если у вас есть возможность писать в эту директорию (в соответствии с тем, к какому типу пользователей вы относитесь).

$ ls -la /home/ | grep kirill
drwxr-xr-x  5 kirill.m          kirill.m          4096 Aug 29 11:34 kirill.m
Домашняя директория имеет другие права. 
Первое отличие — это d вместо - в самом начале. 
d говорит о том, что перед нами директория. 
Права для владельца rwx, а для всех остальных r-x. 
Из этого описания видно, что кроме пользователя никто не может писать внутрь домашней директории этого пользователя.

Что такое x в отношении директорий? 
Это право позволяет перемещаться в директорию и обращаться ко всем расположенным в ней файлам и каталогам. 
Обращаться можно при условии, что эти файлы доступны на чтение или запись или выполнение.
Если же убрать с директории право x, то вы вовсе лишитесь доступа к файлу.

Но что тогда такое чтение? 
Здесь всё более интуитивно понятно: директория, по сути, является списком файлов, 
поэтому право на чтение позволяет прочитать этот список файлов, а именно вывести список имён файлов, 
содержащихся в директории. 
Однако, если хотите посмотреть не простой список имён файлов, а список с дополнительной информацией (как при выводе ls -l), 
то требуется ещё и право x, потому что в этом случае надо обращаться к файлам за их метаданными (владелец, группа, дата изменения, права и др.). 
В любом случае, без права r на каталог вы не сможете посмотреть его содержимое.

другой способ описания прав доступа: 775. 
Это не одно число, а три числа, каждое из которых представляет собой группу rwx для наших типов пользователя в том же порядке: 
для владельца, входящих в группу и всех остальных. 0 — означает, что нет никаких прав для данного типа пользователей.

drwxr-xr-x в числовой форме соответствует 755, а -rw-r--r-- — 644.

Однако пользователь root находится вне этой системы. Для него не имеет никакого значения наличие любых прав — рут может всё.

Для установки программ, особенно связанных с разработкой, придумали пакетные менеджеры.
MacOS - brew
Windows - Chocolatey

Например, установка php в Ubuntu выглядит так:

$ sudo apt install php
# Здесь будет много текста и вопрос, устанавливать ли? Если да, то установится php
$ php -v
PHP 7.2.7 (cli) (built: Jun 22 2018 06:27:50) ( NTS )

Пакетный менеджер состоит из нескольких частей. 
Одна из них взаимодействует с пользователем напрямую — это консольная утилита apt. 
Для установки необходимой программы нужно набрать apt install и далее указать её имя. 
Почти всегда пакетные менеджеры требуют запуска от рута (root), 
так как установка программ происходит в системные директории, недоступные для записи обычному пользователю 
(но это не всегда так, в MacOS не нужно использовать sudo).

$ apt install php
E: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)
E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?

Установленные пакеты можно удалять. Для этого используется команда apt remove:

$ apt remove php
# Тут тоже много вывода и вопрос, удалять ли?

На другом конце провода находится каталог так называемых пакетов. 
Во время попытки установить программу утилита apt выполняет запрос в каталог и пытается понять, есть ли там пакет с таким именем. 
Если его нет, то вы об этом узнаете:

# Пакета wrongname не существует
$ sudo apt install wrongname
Reading package lists... Done
Building dependency tree
Reading state information... Done
E: Unable to locate package wrongname

Для экономии ресурсов (сети) и ускорения работы apt сохраняет индекс (список пакетов в каталоге) на локальный диск и использует его для своей работы. 
Иногда это может приводить к ситуациям, что пакет в реальности существует, но apt утверждает обратное. 
Если вы чувствуете подвох, то запустите ручное обновление локального индекса:

$ sudo apt update
# Теперь можно устанавливать
$ sudo apt install php

Как узнать какой пакет ставить?

Когда появляется необходимость установить определённую программу, 
то самый очевидный способ сделать это, найти сайт программы и выполнить действия, указанные на странице "Скачать" (обычно Download). 
Как правило, на этой странице есть указание о том, как можно использовать пакетный менеджер, с примерами команд, включающих в себя названия пакета. Пример: nodejs.
Другой способ: загуглить статьи в стиле php install ubuntu. 
В таких статьях установка всегда идёт через пакетный менеджер. Со временем вы запомните имена многих пакетов и сможете ставить их "на автомате".

Чем пакет отличается от программы?

Сама программа ничего не знает про существование пакетного менеджера. 
Но чтобы её можно было ставить через менеджер пакетов, она должна быть специальным образом "упакована". 
Это может сделать как автор программы, так и энтузиасты. 
В Ubuntu используется специальный формат пакетов, называемый deb. 
У этого формата есть подробная документация о том, как производить упаковку.

Как программы попадают в каталог?

А вот здесь всё сильно зависит от политики тех, кто его поддерживает. 
В некоторые каталоги попасть очень тяжело и программы в них обновляют медленно. 
Связано это с тем, что разработчики стараются добавлять туда только проверенный софт. 
В других всё происходит просто и быстро. 
В любом случае необходимо пройти некоторую процедуру, после которой программа будет добавлена. 
Это один из ключевых аспектов, по которому дистрибутивы линукса отличаются друг от друга. 
В любом случае эти каталоги огромны, в них входят десятки и сотни тысяч программ и библиотек.

Пакетные менеджеры не являются прерогативой операционных систем: любая экосистема, внутри которой возможно распространение библиотек или программ, 
имеет свой пакетный менеджер. 
Пакетные менеджеры есть у всех языков программирования, иногда несколько, большинство из них включены в языки по умолчанию. 
В nodejs (серверный javascript) пакетный менеджер npm, в php — composer, в ruby — gem, в python — pip.

Запуск программ в командной строке активирует целый механизм по поиску и выполнению этой программы. 
Программа, независимо от того, что она делает, всего лишь файл или набор файлов на диске. 
Один из этих файлов обязательно должен быть исполняемым.
Так вот, выполнить программу можно только если она исполняемая, иначе попытка запустить её приведёт к ошибке.

Весь механизм по запуску программ в *Nix системах основан на соглашениях. 
Когда в командной строке вводится некоторая команда, например, ls, 
то шел начинает поиск исполняемого файла с именем ls в списке директорий, указанном в переменной окружения PATH.

~$ echo $PATH
/home/hex/.local/bin:/home/hex/bin/:/home/hex/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

Директории друг от друга отделяются двоеточием. 
В этом списке присутствуют как общесистемные пути, так и пути, специфичные для конкретного пользователя. 
В вашем случае PATH будет другой. Процесс поиска программы выглядит следующим образом. 
Шел перебирает директории слева направо и ищет ту, в которой есть файл ls, доступный для исполнения. 
Если такого файла не оказалось, то выводится ошибка:

~$ wrongname
bash: wrongname: command not found

важен порядок. Если файл с одним и тем же именем находится одновременно в нескольких директориях, то будет найден тот, который находится в директории, расположенной левее.

Если вам интересно узнать, а где лежит исполняемый файл конкретной программы, то можно воспользоваться командой type (а еще which и whereis):

~$ type cp
cp is /bin/cp
~$
~$ whereis cp
cp: /bin/cp
~$
~$ which cp
/bin/cp
~$
~$ ls -al /bin | grep cp
-rwxr-xr-x 1 root root  141528 Jan 18  2018 cp

По выводу выше видно, что cp принадлежит руту, но исполнять его могут все.

Обратите внимание на то, что почти все директории, в которых хранятся исполняемые файлы программ, оканчиваются на bin. 
Это общее соглашение, говорят "бинарники" (формально там не всегда бинарники, но это не принципиально). 
Пакетные менеджеры знают про эти директории и во время установки программ переносят их бинарники в одну из директорий, входящих в PATH. 
Для вновь устанавливаемых программ обычно это /usr/local/bin. 
Иногда возникает необходимость расширить PATH, особенно в случае установки через пакетные менеджеры языков программирования, 
но делать это надо осторожно, убедившись в том, что по-другому нельзя.

В некоторых ситуациях программа, которую вы хотите запустить, не лежит по путям поиска (прописанным в PATH) и не должна там оказаться. 
Если её исполняемый файл находится прямо в текущей директории, то логично предположить, что если набрать имя файла и запустить его, то программа выполнится. 
На самом деле этого не произойдёт.

Такое поведение сделано в целях безопасности. 
Ведь возможно вы хотели запустить какую-то стандартную программу, а злоумышленник положил в текущую директорию программу с таким же именем, но делающую что-то плохое. 
По этой причине, прямой запуск программ всегда должен быть путём до файла, например path/to/executable/file. 
А если файл лежит в текущей директории? Вот тут-то нам и поможет обращение через точку ./:

~$ pwd
/home/hex
~$ cd test/
~/test$ ls -al
total 16
drwxr-xr-x 2 hex hex 4096 Sep 10 15:24 .
drwxr-xr-x 1 hex hex 4096 Sep 10 15:24 ..
-rwxr-xr-x 1 hex hex   60 Sep 10 15:24 executable
~/test$ executable
bash: executable: command not found
~/test$ ./executable
Hello from executable!
~/test$