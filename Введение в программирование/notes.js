p {
  color: red;
  font-size: 20px;
}

1.	Первая часть — это селектор (selector). Им мы выбираем то, к чему применять стиль.
2.	Набор стилей указан после селектора в фигурных ({, }) скобках.
3.	Набор состоит из пар свойство: значение (property: value).
Изначально стоит использовать в названиях классов семантический смысл, а не особенность реализации. 
Для уникальных «разовых» элементов стоит использовать id
по правилам (спецификации HTML) элемент с идентификатором должен быть уникальным на странице. То есть нет необходимости выбирать именно h1, достаточно сделать так:
#article-title {
  font-family: Georgia, serif;
  color: #1050ff;
}

Такой элемент будет одновременно красным, размером 20 пикселей и курсивом. Но у разных видов селекторов разный приоритет.
Порядок таков:
1.	Селектор типа элемента (p)
2.	Селектор класса (.dance)
3.	Селектор id (#hue)
1 — низкий приоритет, 3 — высокий приоритет.
•	display: block начинается с новой строки и занимает всю ширину
•	display: inline начинается в любом месте и занимает столько ширины, сколько нужно для помещения содержания
Разные браузеры могут задавать разные стили по умолчанию, и иногда эти стили могут отличаться. Поэтому одна и та же страница может выглядеть по-разному в разных браузерах. Это в основном касается размеров и отступов. Для решения этой проблемы существуют так называемые CSS Reset'ы: наборы CSS-стилей, которые «сбрасывают» браузерные стили.
•	div — это block-level элемент, у него свойство display: block.
•	span — это inline-level элемент, у него свойство display: inline.
Мы использовали значение inline-block у свойства display. Это в какой-то степени комбинация inline и block. Элемент не занимает всю ширину и может находится на одной строке с другими элементами. При этом у него можно задать параметры, свойственные block'у: конкретную ширину и высоту.

Правило близости: объекты, расположенные близко друг к другу, воспринимаются связанно. Из этого правила можно вывести более практическую форму: внутренние расстояния элемента должны быть меньше внешних.

Когда Фейсбук стал не просто популярным сайтом, а по-настоящему глобальной социальной сетью, компания решила создать специальный формат разметки, чтобы веб-мастеры могли чётко задать информацию для вывода в ленте Фейсбука. Этот формат называется OpenGraph, и его распознают не только Facebook, но и ВКонтакте, Twitter, LinkedIn и Google+. http://ogp.me/#types
OpenGraph-теги (или og-теги) — это специальные параметры для стандартного элемента meta, который размещается внутри head.
Теги типа article, nav, footer нужны для того, чтобы поисковые роботы могли семантически анализировать страницу. 
(schema markup и ceо посмотреть) Некоторые социальные сети также имеют собственные особенности или форматы для метаинформации. Вы можете найти их по запросу вроде "linkedin meta tags".
Компьютер и языки программирования
У языка программирования есть два аспекта:
- синтаксис (правила написание кода, правописание, порядок слов)
- семантика (идея, смысловая нагрузка)
Некоторые языки программирования имеют похожий синтаксис, некоторые экзотический. Семантику сложно увидеть, она неявная. В современных языках хороший код означает легко понятную семантику. Если понять то, что делает код, сложно, то код не слишком хороший. Синтаксис легко изучить, его необходимо знать, но этого недостаточно. Не так важно с какого языка начать. Это не как выбор языка на котором говорить, а как выбор инструмента, которым писать – ручка, компьютер, кисть.
Версии JS
JavaScript, как и все остальные языки, не стоит на месте. Примерно каждый год выходит новая версия языка, обладающая новыми возможностями. Использовать эти новые возможности сразу после их выхода — нельзя. Это связано с тем, что сам стандарт и его реализация — это две разные вещи. До внедрения этих возможностей в разные среды исполнения (браузеры, nodejs) должно пройти какое-то время.
Выходом из этой ситуации стал Babeljs. Это специальная программа, которая берет исходный код на современном стандарте JS и превращает его в JS-код более старого формата. Такой трюк позволяет начать использовать все самое вкусное уже прямо сейчас, не дожидаясь полноценной поддержки.
Babeljs фактически стал стандартом де-факто и уже сложно представить, чтобы проекты на js делались без него. Это одна из главных причин, почему на Хекслете преподается последний стандарт js.
Другая причина заключается в том, что новый синтаксис стал гораздо более лаконичным и подчеркивающим правильные идеи программирования. Особенно это станет заметно (хотя, для многих и непривычно) в последующих курсах.
Стиль
Как и при работе с естественными языками, код нужно оформлять определенным образом для того, чтобы он был более понятным и простым в поддержке. Конкретно в js самым распространенным стандартом является https://github.com/airbnb/javascript Он был написан программистами компании airbnb и теперь используется повсеместно. Периодически просматривайте его и улучшайте свой код. Следование стандартам не только входит в практики экстремального программирования, но и является неотъемлемой частью при работе в команде.
В любом языке программирования существуют специальные инструменты, так называемые линтеры, задачей которых является проверка кода на соответствие стандартам. В js это eslint.

Способы записи функций

//const <name> = (<argument>) => {
//	return <expressions>;
//};

const identity = (value) => {
	return value;
};

Для однострочных функций
// const <name> = (<argument>) => <expressions>;
const identity = value => value;

Используя ключевое слово function. Это устаревший вариант, есть семантическое отличие

const identity = function(value) {
	return value;
};

Такую функцию можно использовать до ее определения в этом файле

function identity(value) {
  return value;
}

Формальные параметры функции - имена переменных в определении функции.
Фактические параметры функции - то, что было передано в функцию в момент вызова.
Между их именами нет связи, у фактических может вообще не быть имен. Важен только одинаковый порядок.

После слова return функция не выполняется

Условия

Пример записи условий

const (abs) = (num) => {
	if (num > 0) {
		return num;
	} else if (num < 0) {
		return -num;
	} else {
		return 0;
	}
}

Предикат - то, что дает true или false
=== !== > < >= <=

AND (&&) OR (||) NOT (!) 
XOR - это OR без 1 1 = 1

Сокращенная версия if - тернарный оператор

condition ? expression : expression

const absValue = (num === 0 || num > 0) ? num : -num;

Только два варианта -  один для тру, один для фолс
Тернарная операция вычисляется и возвращает значение, те это выражение
Условная конструкция if в js не является выражением. 
Это инструкция, она выполняет действие - не вычисляя и не возврщая.
Не можем присвоить константе значние if и тд

Функция  однострочник с тернарным оператором
const getAbs = num => (num >= 0) ? num : -num;
 - вложенные тернарники ухудшают читаемость кода
 - тернарник не подходит для выполнения блоков кода
 - инструкцию return нельзя использовать внутри тернарного оператора

 Виды ошибок

 Syntax Error - неверное использование языка, часто незакрытые скобки или кавычки.
 Reference Error - использование несуществующего названия. Проверить существование того, на что ссылаешься
 Type Error - использование неверного типа (напр константа как функция). Часто путаница в именах.
 Logic Error - ошибки не вылзают, но код делает не то, что должен. Сломалась логика, проверить, что делает код.

 Самый действенный способ понять, как работает участок кода — это расписать его выполнение на бумажке, как если бы вы были компьютером 
 
Метод утёнка — психологический метод решения задачи, делегирующий её мысленному помощнику. 
Метод описан в книге «Программист-прагматик».

Тестируемый ставит на рабочем столе игрушечного утёнка (или представляет его мысленно; 
на самом деле уточка - это условно, предмет может быть любым), 
и когда у него возникает вопрос, на который трудно ответить, 
то он задаёт его игрушке, как живому человеку, словно она действительно может ответить.

Считается, что правильная формулировка вопроса содержит как минимум половину ответа, 
а также это дает толчок мыслям, направляя их в нужное русло.

Метод также используется при отладке. 
Если определённая часть программы не работает, программист пытается объяснить утёнку, 
что делает каждая строка программы, и в процессе этого сам находит ошибку.

Рекурсия

Определение функции - это описание коробки.
Оригинал коробки формируется при вызове функции.
Когда функция вызывает сама себя, создается новая идентичная коробка.

Перестановки и факториал
Количество способов перестановки n объектов - т!
n! определяется таким способом - если n = 1, то n! = 1; если n>0, то n! = n*(n-1)!

const factorial = (n) => {
	if (n === 1) {
		return 1;
	}
	else{
		return n * factorial(n-1);
	}
}

const answer = factorial(3);

Требования рекурсии:
1. Простой базовый случай (когда остановиться)
2. Правило углубления

В факториале ничего не умножается, пока не дойдем до базового случая.
Дальше поднимаемся обратно и умножаем.

0! = 1, а простой базовый случай для n! это 0!

Итеративный процесс
Рекурсия - абстрактная концепция содержания самого себя в своем описании
Рекурсивный процесс - откладываение вычислений до самого конца.
Вся информация о вычислениях в конкретный момент называется состоянием.
Во время рекурсивного процесса создается множество состояний - потому
что функции вызываются по очереди и не закрываются, пока процесс не пойдет в обратном
порядке.
Суть итеративного процесса - вычисление с фиксированным количеством состояний.
Вычисления производятся по чуть чуть на каждом шаге.

const factorial = (n) => {
	const iter = (counter, acc) => {
		if (counter = 1) {
			return acc;
		}
		return iter(counter - 1, counter * acc);
	};

	return iter(n, 1);
}

1. Считаем от n до 1
2. Берем число из предыдущего шага
3. Умножаем это число на текущее число
4. Передаем его в новый шаг
5. Конгда conter достигает 1, число передается из предыдущего шага в ответ
Так как нужно с чего то начинать, в начале acc равно 1, и counter*1 = counter

Итеративынй процесс в целом: 
Определить начальное состояние. В нашем случае мы делаем первый вызов iter с n и 
1. Это начальное состояние.
​2. Проверить терминальный сценарий. Мы убеждаемся, что counter это 1 и останавливаем рекурсию, когда он достигает значения 1.
​3. Определить новое состояние. Это то, как продвигается процесс. В нашем случае мы делаем ещё один вызов iter с уменьшенным counter и умноженным accumulator. Два этих новых числа определяют новое состояние.
4. Повторить шаг 2.​

Рекурсия — это когда что-то содержит себя в своём описании.
Рекурсивный процесс — это процесс обработки данных с отложенными вычислениями.
Итеративный процесс — это процесс вычисления, когда состояние может быть описано фиксированным количеством значений.

Декларативное и императивное программирование
Два варианта факториала
const recursiveFactorial = (n) => {
  if (n === 1) {
    return 1;
  }
  return n * recursiveFactorial(n-1);
}
Эта рекурсиваная функция - декларативная.
Она как бы определение (трактование, характеристика) факториала.
Она декларирует, что такое факториал.
От латинского "clarare" — разъяснять, заявлять, делать объявление. 
Вы разъясняете: я хочу, чтобы факториал n был n раз факториалом n-1.

const factorial = (n) => {
  let counter = 1;
  let result  = 1;

  while (counter <= n) {
    result = result * counter;
    counter = counter + 1;
  }

  return result;
}
Эта нерекурсивная итеративная функция — императивная — описание того, что нужно делать, чтобы найти факториал.
От латинского "imperare", что значит "командовать". Вы приказываете чётко передвигаться по шагам — умножать это на это, пока идёт отсчёт и запоминаются какие-то числа.
Декларативное — это что. Императивное — это как.
Переменные, циклы и изменение состояния - этопро императивное программирование.

Писать декларативный код лучше, он более понятный, но не всегда есть выбор.
От изменения состояния появляются бага, а операторы присваивания - это часто зло.
Когда дело доходит до инструкций присваивания, стоит действовать осторожно.

let - более современный и правильный вариант var
let и var по разному влияют на видимость переменной, и использование var сегодня не желательно. let был создан как более правильная альтернатива старому способу.


Строки

Строка - последовательность символов. Создание строк
const str1 = "Hello";
const str2 = 'Hello';

Использование ковычек внутри Строки
const str1 = 'They call him "Harry", and he likes it';
const str2 = "They call him 'Harry', and he likes it";

Если одного типа кавычки, то они экранируются
const str1 = 'They call her \'Ann\', and she likes it';
const str2 = "They call her \"Ann\", and she likes it";
Другие примеры экранирования
const str = "This is a backslash \\ here"
// This is a backslash \ here
Управляющие символы
const str = "There is a tab \t and here \ncomes the new line!"

// Here is a tab    and here
// comes the new line!

Склеивание строк - конкатенация +
const name = "Alex";
const age = 22;
console.log("His name is " + name + " and his age is " + age);

// His name is Alex and his age is 22
 доступ по индексу - str[i] это i-ый символ строки str, начинающейся с 0

 В JS строки неизменяемы, все функции, меняющие строку, возвращают новую строку, а не
 производят inplace замены. Это верно и в том случае, когда мы обращаемся к конкретному символу в строке.

 Можно сравнивать строки < >. Сравнение будет лексикографическим ( в алфавитном порядке).

Интерполяция строк. 
Обратные тики (backticks): ``
Интерполяция предпочтительнее конкатенации
Мы советуем не использовать конкатенацию вообще. Вот некоторые из причин:
- Такой код заставляет больше думать, потому что синтаксически + больше смахивает на сложение.
- Из-за слабой типизации можно легко получить не тот результат. Конкатенация может породить ошибки.
- Сложные строки при использовании конкатенации невозможно нормально разобрать в голове и понять, как они устроены.

const name = "Alex";
const a = 10;
const b = 12;
console.log(`His name was ${name} and his age was ${a + b}`);

Циклы for и шорткаты

b *= a;    // same as b = b * a
b += a;    // same as b = b + a
b -= a;    // same as b = b - a
b %= a;    // same as b = b % a

Операторы инкрементирования и декрементирования:

// Postfix
let a = 3;
let b;
b = a++;    // b = 3, a = 4

// Prefix
let a = 3;
let b;
b = ++a;    // b = 4, a = 4

Их лучше не использовать. Они непонятные, поэтому линтеры настроены так, чтоб на них ругаться.

Пример цикла for
const factorial = (n) => {
  let result  = 1;

  // initialization↓    condition↓     update↓
  for (let counter = 1; counter <= n; counter++) {
    result *= counter;
  }

  return result;
}

все 3 выражения в цикле for не обязательны
let counter  = 1;
for (;;) {
  if (counter <= n) break;
  // любой код
  counter++;
}

Конструкция switch

switch(num) {
  case 1:  // if (num === 1)
    answer = "One";
    break;

  case 2:  // if (num === 2)
    answer = "Two";
    break;

  default:
    answer = "Nothing";
    break;
}

break нужен чтобы выйти из блока switch. 
если он отсутствует, выполнятся все последующие инструкции, игнорируя проверки
Если в примере выше убрать все break'и, а num равен 1, то выполнятся все строки:
answer = "One";
answer = "Two";
answer = "Nothing";
}
Так что в итоге answer будет иметь значение "Nothing".

Несколько значений case можно группировать.

switch(num) {
  case 1:  // if (num === 1)
    answer = "One";
    break;

  case 2:  // if (num === 2)
  case 3:  // if (num === 3)
  case 4:  // if (num === 4)
    answer = "Two to four";
    break;

  default:
    answer = "Nothing";
    break;
}

assert - это общее название для тестовых функций, а так же название библиотеки тестирования JavaScript.
assert(square(2) === 4);
А вот как он жалуется, если выражение не истинно:

Assertion error: false == true
  at square (/home/rakhim/code/planets.js:4:3)
  at surfaceArea (/home/rakhim/code/planets.js:8:10)

Это специальная отдельная функция для проверки равенства:

assert.equal(square(2), 4);
А вот как она жалуется, если тест валится:

Assertion error: 6 == 4
  at square (/home/rakhim/code/planets.js:4:3)
  at surfaceArea (/home/rakhim/code/planets.js:8:10)

Важно не забывать пропограничные случаи

Модули

В JS один модуль - один файл. Объединение кода, расположенного в разных модулях, происходит через:
Экспорт чего-то из модуля.
Импорт в другой модуль.
Поставьте export перед тем, что вы хотите экспортировать. Такая операция сделает это импортируемым куда угодно:

export const pi = 3.14;
export const e = 2.718;

export const square = (x) => {
  return x * x;
};

export const surfaceArea = (r) => {
  return 4 * pi * square(r);
};

Импорт
import { surfaceArea, square } from './math';

const surfaceOfMars = surfaceArea(3390);
const surfaceOfMercury = surfaceArea(2440);
const yearSquared = square(2017);

Или импортируйте всё:

import * as mathematics from './math';

const surfaceOfMars = mathematics.surfaceArea(3390);
const surfaceOfMercury = mathematics.surfaceArea(2440);
const yearSquared = mathematics.square(2017);


Экспорт по умолчанию
Вы можете сделать одну позицию экспортируемой по умолчанию.

const pi = 3.14;
const e = 2.718;

const square = (x) => {
  return x * x;
};

const surfaceArea = (r) => {
  return 4 * pi * square(r);
};

export default surfaceArea;
Можно также экспортировать функцию или константу без имени:

const pi = 3.14;
const e = 2.718;

const square = (x) => {
  return x * x;
};

export default (r) => {
  return 4 * pi * square(r);
};
Импортирование чего-то, что было экспортировано по умолчанию:

import surfaceArea from './math';

const surfaceOfMars = surfaceArea(3390);
При экспорте функции без имени, её имя в модуле будет определяться в момент импорта, т.е. один и тот же экспорт может иметь разные имена в разных модулях:

math.js

export default () => {
  ///
};
import1.js:

import something1 from './math';
import2.js:

import something2 from './math';

Анализ кода
Почти все уроки этого курса, а также остальные курсы на Хекслете используют модули. Такой подход максимально приближает нас к реальной жизни, когда проекты состоят из сотен, тысяч файлов и библиотек, которые пользуются друг другом.

При работе с модулями будет полезным сразу наработать некоторые модели поведения, позволяющие вам с легкостью определять, какой код вам доступен на исполнение, откуда пришел этот код и как его увидеть.

Ниже описан основной алгоритм, по которому нужно анализировать файл с кодом, над которым вы сейчас работаете. Этот алгоритм не является специфичным для работы в среде Хекслета, так нужно делать в принципе:

Внимательно изучите все импорты, описанные в начале файла. Так вы узнаете, какие модули и функции доступны внутри вашего файла (не считая глобальных функций и модулей, которые доступны и без импорта, например, Math).
Попробуйте классифицировать импортируемые функции. Если импорт выглядит так from './..., то есть содержит ./, значит импортируется модуль, содержимое которого находится в текущей файловой системе. Это автоматически означает несколько вещей. Первое: вы всегда можете открыть этот файл и посмотреть, что там написано. Второе: вы не сможете импортировать этот модуль в другой среде (ведь этого файла там нет).
Если from 'name' содержит только имя, без ./ в начале, значит модуль подгружается либо из стандартной библиотеки nodejs, либо из установленных пакетов. Визуально невозможно отличить одно от другого. Попробуйте загуглить имя таким способом: "nodejs name". Если в выдаче будет ссылка на официальную документацию, значит это модуль nodejs; если на репозиторий npm — значит, это обычный пакет, который почти наверняка лежит на гитхабе, что можно проверить таким запросом: "github js name", где "name" это имя пакета.

Выражения и инструкции
Выражением (expression) является любой корректный блок кода, который возвращает значение.
const x = 5;
const y = getAnswer();

Процесс выполнения выражений
12 + square(7 + 5) + square(square(2));

12 + square(12) + square(square(2));
12 + 144 + square(square(2));
12 + 144 + square(4);
12 + 144 + 16;
156 + 16;
172;

JavaScript различает выражения (expressions) и инструкции (statements). Инструкция — это (грубо говоря) команда, действие.
if, while, for, const — примеры инструкций. Они производят или контролируют действия, но не превращаются в значения.

область видимости (scope) компонентов - местоположение, где эти компоненты доступны
компоненты, созданные снаружи функций, циклов, условий находятся в глобальной области видимости
фигурные скобки задают новую локальную область видимости

Локальные константы и переменные не видимы снаружи их области видимости:

const multiplier = (num) => {
  const x = 10;
  return num * x;
}

console.log(x);     // ReferenceError: x is not defined

Под лексической областью видимости можно понимать просто механизм поиска значений: 
смотрим в текущей области, если нет — идём на уровень выше, и так далее. 
Слово «лексический» означает, что видимость задаётся исключительно текстом программы, исходным кодом. 
То есть можно смотреть на программу, не запуская её, и понять область видимости в любой точке.

В других языках может быть не лексический механизм, а динамический (dynamic scope) - видимость зависит от состояния, время вызова интерперетатором.

Лексическая область видимости
JavaScript пытается найти значение в текущем окружении. 
Но значение не находится и JavaScript выходит наружу, на один уровень за попытку, пока не найдёт значение или не поймет, что значение невозможно найти.

let a = 7;
let b = 10;

const multiplier = () => {
  let a = 5;
  return a * b;
}

multiplier(); // 50
Здесь, в выражении a * b , функция multiplier использует локальную a (потому что она обнаружена локально), и наружную b (потому что локально b найдена не была).

Замыкания
const createPrinter = () => {
  const name = "King";

  const printName = () => {
    console.log(name);
  }

  return printName;
}

const myPrinter = createPrinter();
myPrinter();    // King
myPrinter — это функция, которая была возвращена createPrinter. 
Несмотря на то, что вызов createPrinter окончен и константы name больше не существует, значение запомнено в myPrinter.
Это замыкание: сочетание функции и окружения, где она была заявлена. (?)

Типизация
JavaScript имеет представление о типах: числах, строках, функциях, логических значениях и так далее. typeof возвращает строку, в которой записан тип:

typeof 42;      // 'number'
typeof 3.14;    // 'number'
typeof NaN;     // 'number'

typeof 'Berry'; // 'string'
typeof true;    // 'boolean'
typeof false;   // 'boolean'

NaN - не число, но тип - number

Переменная без значения - undefined. Можно задать саомому, но лучше не надо - это сделано для компа.
let a;
console.log(a);   // undefined
typeof a;         // 'undefined'

Статически типизированные языки проверяют типы и ищут ошибки типизации на стадии компиляции.
Динамически типизированные языки проверяют типы и ищут ошибки типизации на стадии исполнения.

JavaScript часто конвертирует типы автоматически:

4 + '7';      // '47'
4 * '7';      // 28
2 + true;     // 3
false - 3;    // -3

JavaScript — это язык со слабой типизацией. 
У него есть представление о типах, но он расслаблено к ним относится и может оперировать значениями произвольно. 
Чем сильнее система типизации, тем строже правила.
Один язык может быть типизирован чуть сильнее, чем другой.
Явные конверсии в JavaScript
Number('590');    // 590
Number('aaa!!');  // NaN
Boolean(1);       // true
Boolean(0);       // false
String(true);     // 'true'
String(false);    // 'false'
String(44843);  // '44843'

null нужен для явного, намеренного указания, что значения нет. 
Можно сказать let a = null;. 
Например, вы попросили пользователя ввести информацию, но он ничего не ввел. 
В таком случае уместно записать в результат null.
null можно задавать вручную
При сравнении null и undefined нужно быть осторожным:

typeof null;          // "object" (не "null" по историческим причинам)
typeof undefined;     // "undefined"
null === undefined;   // false

null == undefined;    // true
null === null;        // true
null == null;         // true
!null;                // true

isNaN(1 + null);      //false
isNaN(1 + undefined); //true

В JavaScript есть расслабленное сравнение, с двумя знаками равенства. 
Они показывают, что происходит внутри JavaScript, когда он обрабатывает типизации:

1 === '1';    // false
1 == '1';     // true

true === 1;   // false
true == 1;    // true

Детерминированная функция всегда возвращает одинаковые значения при одинаковом вводе
const surfaceAreaCalculator = (radius) => {
  return 4 * 3.14 * square(radius);
}
Недетерминированная функция не всегда возвращает одинаковые значения при одинаковом вводе.
Например, рандомные числа или определение погоды по координате.
Math.random();      // 0.6822304980945362
Math.random();      // 0.34656303876811245
Math.random();      // 0.44983037125501646

Побочные эффекты это то, как функция влияет на внешний мир.
surfaceAreaCalculator не имеет никаких побочных эффектов. Она ничего не меняет за пределами своих границ.
console.log() меняет внешний мир - она выводит что-то на экран.

let a = 0;

const f = () => {
  a = a + 1;
  return true;
}

f();

функция f меняет значение глобальной переменной a.
Эта переменная, с точки зрения функции, находится во внешнем мире, а функция f это меняет. 
Поэтому f имеет побочный эффект.

И f, и console.log имеют побочные эффекты, но они детерминированные. 
f всегда возвращает true, а console.log всегда возвращает undefined.
То, что функции возвращают, не имеет ничего общего с тем, как они влияют на внешний мир.
console.log("Hello!");      // prints "Hello!", but returns undefined

Чем меньше побочных эффектов имеет функция, тем лучше.
Когда функция детерминированная и не имеет побочных эффектов, мы называем её "чистой" функцией. Чистые функции:
- проще читать
- проще отлаживать
- проще тестировать
- не зависят от порядка, в котором они вызываются
- просто запустить параллельно (одновременно)
Чистые функции независимы от времени. 
Недетерминизм и побочные эффекты добавляют понятие времени. 
Если функция зависит от чего-то, что может случиться, а может не случиться и меняет что-то за пределами своих границ, 
то она неожиданно становится зависимой от времени.

