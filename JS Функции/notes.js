Необходимая сложность - сложность функции по объективным причинам.
Случайная сложность - сложность функции, завышенная программистом.

Цикломатическая сложность - это структурная, или топологическая, мера сложности компьютерной программы.
Цикломатическая сложность части программного кода - количество линейно независимых маршрутов через код.
Если нет ветвлений и циклов, то равна 1.
Если один if с простым условием - сложность 2, 2 пути через код.

// Complexity: 1
const sum = (a, b) => a + b;
sum(1, 3); // => 4

// Complexity: 2
const abs = n => (n >= 0 ? n : -n);

abs(10); // => 10
abs(-3); // => 3

Чем больше возможных путей выполнения, тем сложнее понять, отладить и модифицировать функцию.
Необходимо избегать лишних путей.
Линтеры многих языков измеряют показатель сложности.

Паттерн Guard Expressions для понижения сложности.
const f = (age, sex) => {
  if (age >= 18) {
    if (sex === 'male') {
      return 'yes';
    } else if (sex === 'female') {
      return 'no';
    }
  }

  return null;
}

Можно вынести условие age < 18 в Guard Expression, исключив ветвление и вложенные конструкции.
Проведем рефакторинг - улучшение работающего кода без изменения функциональности.
const f = (age, sex) => {
  if (age < 18) {
    return null;
  }

  if (sex === 'male') {
    return 'yes';
  } else if (sex === 'female') {
    return 'no';
  }
}

Теперь основная логика находится вне условных конструкции.
Так же выглядят терминальные уловия в рекурсии.