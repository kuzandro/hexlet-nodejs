Необходимая сложность - сложность функции по объективным причинам.
Случайная сложность - сложность функции, завышенная программистом.

Цикломатическая сложность - это структурная, или топологическая, мера сложности компьютерной программы.
Цикломатическая сложность части программного кода - количество линейно независимых маршрутов через код.
Если нет ветвлений и циклов, то равна 1.
Если один if с простым условием - сложность 2, 2 пути через код.

// Complexity: 1
const sum = (a, b) => a + b;
sum(1, 3); // => 4

// Complexity: 2
const abs = n => (n >= 0 ? n : -n);

abs(10); // => 10
abs(-3); // => 3

Чем больше возможных путей выполнения, тем сложнее понять, отладить и модифицировать функцию.
Необходимо избегать лишних путей.
Линтеры многих языков измеряют показатель сложности.

Паттерн Guard Expressions для понижения сложности.
const f = (age, sex) => {
  if (age >= 18) {
    if (sex === 'male') {
      return 'yes';
    } else if (sex === 'female') {
      return 'no';
    }
  }

  return null;
}

Можно вынести условие age < 18 в Guard Expression, исключив ветвление и вложенные конструкции.
Проведем рефакторинг - улучшение работающего кода без изменения функциональности.
const f = (age, sex) => {
  if (age < 18) {
    return null;
  }

  if (sex === 'male') {
    return 'yes';
  } else if (sex === 'female') {
    return 'no';
  }
}

Теперь основная логика находится вне условных конструкции.
Так же выглядят терминальные уловия в рекурсии.

Значения по умолчанию
Позволяют избежать undefided, если параметр не передан в функцию
const greeting = (name = 'anonymous') => console.log(`Hi, ${name}!`);

greeting();
// => Hi, anonymous!

Работает он следующим образом. 
Если параметр не передан, то подставляется значение по умолчанию (то, что справа от оператора =). 
Если параметр передан, то переприсваивания не происходит. 
Параметр будет равен тому значению, которое было фактически передано в функцию.
Кроме того, в значениях по умолчанию можно использовать идентификаторы:

const f = (x = Math.PI) => {};
И даже вызовы функций:

const f = (x, y = Math.sqrt(x)) => {};
Но не стоит злоупотреблять этим способом. 
Значения по умолчанию не всегда подходят для полноценного программирования.
Можно еще вот так круто проверять, есть ли значение 
const greeting = name => console.log(`Hi, ${name ? name : 'anonymous'}!`);
Что будет, если при вызове передать большее количество параметров, чем установлено в определении функции?
Ответ: ничего не произойдёт они будут просто проигнорированы.

Выполение функций
Выражение — код, выполнение которого возвращает значение. Инструкция — код, представляющий собой команду.
Выражения — вычисляются.
Инструкции — исполняются.

К выражениям относятся:
Вызов функции
Арифметические и логические операции
Тернарный оператор
и другие

К инструкциям относятся:
for
while
break
return
if
и другие

const value = if (something) {
    one
  } else {
    two
  };

Так делать нельзя, потому что if в js  - это инструкция
конструкции языка, представленные выражением, делают язык гибче, а решения с их использованием делают код лаконичнее. 
Другими словами, язык становится выразительнее. 
Кроме описанного выше, у выражений есть еще одно огромное преимущество: 
они могут комбинироваться друг с другом и вкладываться друг в друга.

Варианты комбинирования
Арифметические операции
const r1 = 5;
const r2 = 5 + 8;
const r3 = 5 + 8 - Math.PI;
const r4 = 5 + 8 - Math.PI * Math.sqrt(16);
const r5 = f1() + f2() * f3();

Функции возвращают результаты, так что так писать можно. 
Но если вернут не тот тип данных, будет логическая ошибка.

То же самое работает с логическими операциями 
const r1 = true;
const r2 = true || false;
const r3 = true || false && isEditing;
const r4 = true || false && isEditing || isEmpty(data);
const r5 = f1() || f2() && f3();

Из-за слабой типизации будет работать, что бы функции не возвращали
Но нужно быть внимательным

Аргументы - можно так
const r1 = f();
const r2 = f(5);
const r3 = f(5 + Math.PI);
const r4 = f(5 + Math.PI - cube(number));
const r5 = f(f1(f2(n3, f3(n1, n2))), f4());

JavaScript - эергичный язык, то есть язык с аппликативным порядком вычисления.
Это значит, что аргументы вычисляются до того, как попадают внутрь функции.

const f1 = () => console.log('called f1');
const f2 = () => console.log('called f2');
const f3 = () => console.log('called f3');
const f4 = () => console.log('called f4');
const f5 = () => console.log('called f5');
const f6 = () => console.log('called f6');

f1(f2(f4(), f5()), f3(f6()));

// called f4
// called f5
// called f2
// called f6
// called f3
// called f1
Как видно, вычисление идет с самого глубокого уровня слева направо.

Объекты первого класса (first-class sitizens)
объекты, которые могут быть переданы как параметр, возвращены из функции или присвоены перменной.
const x = () => console.log('hey')
1. Создание функции: () => console.log('hey')
2. Создание константы со значением в виде функции: const x =

минимальное определение функции () => {}
можно присваивать или не присваивать константе
функция — тоже данные, ведь ее можно присвоить константе
Вот такая программа будет работать 
  (a, b) => a + b;
Пример присвоения функции identity константе
const identity = v => v; // функция: v => v, константа: identity
console.log(identity(10)); // => 10

const z = identity;
console.log(z === identity); // => true

const x = 5;
console.log(z(x) === identity(x)); // => true

Определение функции (не вызов!) — это выражение, а значит оно возвращает значение, а именно — функцию.
Можно попробовать вызвать функцию без промежуточной константы

// Определяем функцию v => v и тут же вызываем ее
(v => v)('run'); // => run

// Тот же код с использованием промежуточной константы.
// Попробуйте мысленно заменить `identity` на `v => v`, тогда
// получится (v => v)('run'). С выражениями так можно поступать всегда.
// const identity = v => v;
// identity('run'); // => run

Скобки здесь используются для группировки, иначе будет другой смысл v => v('run') - создается функция, принимающая на вход другую функцию v и вызывающая ее внутри с аргументом 'run'

identity(v => v)('run'); // => run
// (v => v)(v => v)('run') // => run

((a, b) => a + b)(3, 2); // => 5
// const sum = (a, b) => a + b;
// sum(3, 2); // => 5

В общем, можно здавать функцию прям в вызове

const sqrt = identity(Math.sqrt);
console.log(sqrt === Math.sqrt); // true
sqrt(4); // => 2

В первой строчке вызывается функция identity, в которую передается Math.sqrt. Результатом этого вызова будет все та же функция Math.sqrt.
Функции, которые принимают на вход другие функции или возвращают другие функции, называются функциями высшего порядка.
В функциональных языках большинство задач, связанных с обработкой данных, работают именно через них.

const sum = identity((a, b) => a + b);
sum(3, 5); // => 8

// const f = (a, b) => a + b;
// const sum = identity(f);
// sum(3, 5); // => 8

Внутрь функции передается функция, определеяемая в аргументах. Такое часто используется
Внутренние функции, как правило, нужны только здесь и сейчас.
У такой функции нет имени (вообще у любой его нет, даже у такой const f = () => {}, f это имя константы)
Это анонимные или лямбда функции ( в честь формального лямбда исчисления, которое легло в основу сеймейства языков lisp)
но в лямбда исчислении у таких функций только один аргумент, поэтому название не точно.
общее - анонимность и то, что это объекты первого класса

Иногда нужно вызвать фнкцию дважды. Math.sqrt(Math.sqrt(16))
для этого напишем функцию высшего порядка callTwice

const callTwice = (f, arg) => f(f(arg));

callTwice(Math.sqrt, 16); // => 2
callTwice(x => x ** 2, 3); // => 81
// const f = x => x ** 2;
// f(f(3));

Происходит что-то такое
const res1 = f(arg);
const res2 = f(res1);
return res2;

Лексическое окружение (LexicalEnvironment)
Словарь — это набор пар «ключ - значение». Зная ключ, можно получить значение.
Когда функция вызывается, внутри интерпретатора создается словарь, привязанный к этому вызову
Все определения констант, переменных и тд записываются в словарь
Лексическое окружение - хранилище для данных в памяти и механизм для извлечения этих данных при обращении
const showWarning = (field) => {
  // LexicalEnvironment = { field: 'email' }
  const warning = `verify your ${field}, please`;
  // LexicalEnvironment = { warning: 'verify your email, please', field: 'email' }
  console.log(warning);
}

showWarning('email'); // => verify your email, please

Код console.log(warning) активизирует поиск значения идентификатора warning в лексическом окружении.

изменение значений переменных в процессе выполнения функции отражается в лексическом окружении
после выполнения функции лексическое окружение удаляется, занятая им память освобождается

окружение есть и у модуля - любой идентификатор, определенный на его уровне, попадает в лексическое окружение модуля
также есть глобальное окружение (функции console.log, Math.sqrt)

const number = 5;
const square = () => number ** 2;
square(); // => 25

Это работает. Поиск идет по локальному окружению -> уровню модуля -> глобальному окружению
Внешним окружением по отношению к функции считается окуржение, в котором функция была объявлена (не вызвана)

Так сработает:

// module1.js
const number = 5;
export const square = () => number ** 2;

// module2.js
import { square } from './module1';
square(); // => 25
А так нет:

// module1.js
export const square = () => number ** 2;

// module2.js
import { square } from './module1';

const number = 5;
square(); // => ReferenceError: number is not defined

(во втором примере внешнее окружение функции в другом модуле)

Перменная может быть объявлена после функции, главное
чтобы вызов функции происходил после объявления переменной,
те поиск начинался, когда переменная уже записана в окружение

const square = () => number ** 2;
const number = 5;

square(); // => 25

Изменение переменной - изменение значения ключа в окружении
если изменить значение
Обращение переменной внутри функции всегда вернет последнее присвоенное значение
поэтому функция перестает быть чистой
const square = () => number ** 2;

let number = 5;
square(); // => 25

number = 3;
square(); // => 9

Вложенные функции имеют доступ к атрибутам и переменным внешней функции, благодаря тому, как работает окружение
const factorial = (n) => {
  const iter = (counter, acc) => {
    if (counter > n) {
      return acc;
    }
    return iter(counter + 1, counter * acc);
  };

  return iter(1, 1);
};

factorial(5); // => 120

Перекрытие (Shadowing)
Перекрытием называется такая ситуация, когда во внутреннем окружении создается идентификатор с таким же именем, как и во внешнем.
Причем не важно, что это: аргумент функции, константа или переменная.
const f = (coll) => {
  const iter(item, coll) => {
    // using coll
  }
  // ...
}

Код остается рабочим, но из внутреннего окружения уже невозможно обратиться к идентификатору из внешнего
такой код еще и сложнее в анализе, ведь нужно помнить не только названия, но и контекст переменных
линтер будет ругаться на такое как на плохую практику программирования

Функция запоминает внешнее окружение во время определения

Функции — это такие же данные, как числа или строки, поэтому функции можно передавать в другие функции в виде аргументов, а также возвращать из функций.
const generateSumFinder = () => {
  const sum = (a, b) => a + b;     // создали функцию
  return sum;                      // и вернули её
};

const sum = generateSumFinder();   // sum теперь — функция, которую вернула функция generateSumFinder
sum(1, 5); // => 6                 // sum складывает числа

Можно без промежуточной константы
// вызвали функцию, которая возвращает функцию,
// и тут же вызвали возвращенную функцию

generateSumFinder()(1, 5);    // => 6
// ((a, b) => a + b)(1, 5)

когда видите подобные вызовы f()()(), знайте: функции возвращаются!

// предыдущий вариант для сравнения
// const generateSumFinder = () => {
//   const sum = (a, b) => a + b;
//   return sum;
// };

// новый вариант
const generateSumFinder = () => (a, b) => a + b;

Определение функции обладает правой ассоциативностью. Все, что находится справа от =>, считается телом функции. Количество вложений никак не ограничено. Вполне можно встретить и такие варианты:

const sum = x => y => z => x + y + z;

// расставим скобки для того чтобы увидеть как функции вложены друг в друга
// const sum = x => (y => (z => x + y + z));

sum(1)(3)(5); // => 9

После каждого вызова (кроме последнего) возвращается новая функция, в которую подставлено значение из внешней функции за счет замыкания.

const sum = x => y => z => x + y + z;
// const sum = x => (y => (z => x + y + z));
Функция sum принимает x и возвращает функцию, которая
принимает y и возвращает функцию, которая
принимает z и возвращает функцию, которая
возвращает сумму x + y + z

Напишем функцию generate, которая не применяет функцию сразу, а генерирует новую.

const generate = f => arg => f(f(arg));
// const generate = f => (arg => f(f(arg)));
Функция generate принимает функцию в качестве аргумента и возвращает новую функцию. Внутри новой функции переданная изначально функция вызывается два раза:
Ещё пример: передадим в функцию generate новую функцию на ходу, без предварительного создания. Переданная функция возводит число в квадрат.

const f2 = generate(x => x ** 2);
f2(4); // => 256
// generate(x => x ** 2)(4);
Теперь функция f2 возводит число в квадрат два раза
Функция generate имеет такое имя не просто так. Дело в том, что возврат функции порождает каждый раз новую функцию при каждом вызове, даже если тела этих функций совпадают:

const f1 = generate(x => x ** 2);
const f2 = generate(x => x ** 2);
console.log(f1 === f2); // => false
Поэтому про любую функцию, которая возвращает функцию можно сказать что она генерирует функцию.

замыкания
const generateDouble = f => arg => f(f(arg));
const f1 = generateDouble(Math.sqrt);
Когда generateDouble закончила работу и вернула новую функцию, экземпляр функции generateDouble исчез, уничтожился вместе с используемыми внутри аргументами.

Но та функция, которую вернула generateDouble все еще использует аргумент. 
Технически внутренняя функция, как и любая другая в JS, связана со своим лексическим окружением, которое не пропадает, даже если функция покидает это окружение.

Функция, которая была возвращена из generateDouble, называется замыканием. 
Замыкание — это функция, «запомнившая» часть окружения, где она была задана. 
Функция замыкает в себе идентификаторы (все, что мы определяем) из лексической области видимости.

Можно смоделировать функцию savePassword, которая принимает на вход пароль и возвращает предикат, то есть функцию, возвращающую true или false, для его проверки.
const secret = 'qwerty';
// Возвращается предикат.
const isCorrectPassword = savePassword(secret);

// Теперь можно проверять
console.log(isCorrectPassword('wrong password')); // => false
console.log(isCorrectPassword('qwerty')); // => true

А вот как выглядит код функции savePassword:

const savePassword = password => passwordForCheck => password === passwordForCheck;

Частичное применение функций
Частичное применение позволяет на основе старой функции, создать новую, которая "частично применена". 
В js эта возможность не встроена прямо в сам язык, но ее можно реализовать с помощью дополнительной функции:

const sum = (a, b, c) => a + b + c;

// Берем исходную функцию sum и отдаем ее в функцию partialApply
const sumWithFour = partialApply(sum, 4);
sumWithFour(3, 1); // 8
sumWithFour(10, 3); // 17

const sumWithFourAndTwo = partialApply(sumWithFour, 2);
sumWithFourAndTwo(3); // 9

Функция partialApply принимает на вход исходную функцию и параметры которые нужно применить, а возвращает новую, частично примененную функцию.
partialApply для функций от трёх аргументов (таких как sum):

const partialApply = (fn, arg1) => (arg2, arg3) => fn(arg1, arg2, arg3);

Пример из реальности:
Предположим, что мы пишем программу, вычисляющую зарплату людей разных специальностей по всему миру. Для этого используется функция getAverageSalary.

const salary1 = getAverageSalary('programmer', 'spain');
const salary2 = getAverageSalary('programmer', 'russia');
const salary3 = getAverageSalary('programmer', 'usa');

Уберем повторяющийся ввод programmer с помощью константы
const job = 'programmer'
const salary1 = getAverageSalary(job, 'spain');
const salary2 = getAverageSalary(job, 'russia');
const salary3 = getAverageSalary(job, 'usa');
Название профессии больше не повторяется, но нам по-прежнему приходится подставлять его в каждый вывод. Здесь на помощь приходит так называемое частичное применение функции.

const getProgrammersSalaryByCountry = partialApply(getAverageSalary, 'programmer');

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

Тело функции getProgrammersSalaryByCountry выглядит предсказуемо. Внутри вызывается исходная функция с подставленным в аргумент значением.

const getProgrammersSalaryByCountry = country => getAverageSalary('programmer', country);
А partialApply для функций от двух аргументов, реализуется способом очень похожим на реализацию flip.

const partialApply = (fn, arg1) => arg2 => fn(arg1, arg2);
То есть функция partialApply возвращает (генерирует) функцию, которая внутри себя замыкает два параметра: fn и arg1.

Из-за асинхронной природы JS часто бывают ситуации, когда одни параметры функции задаются в одном месте, а другие в другом, 
так как они становятся доступны только после выполнения асинхронной операции. 

Каррирование

Каррирование — это процесс превращения функции от n аргументов в цепочку вложенных n-функций от одного аргумента. 
Соответственно, каррированная функция — это множество функций от одного аргумента.

const sum = (a, b, c) => a + b + c
Тогда ее каррированная версия
const sum2 = a => b => c => a + b + c
sum2(5)(10)(-2)

const sum2 = (a) => {
  return (b) => {
    return (c) => {
      return a + b + c;
    };
  };
};


a => b => c => a + b + c
Суммарное количество функций равно сумме всех стрелок =>
Для лучшего понимания можно добавить скобки a => (b => (c => a + b + c))
Для каждого определения функции все, что находится справа от стрелки, является ее телом, каким бы сложным оно не было.

const sum2 = a => b => c => originalSum(a, b, c) 
То есть создается цепочка вложенных функций, 
в которой количество вложений равно количеству аргументов исходной функции 
и в конце которой происходит вызов оригинальной функции.

Представим, что теперь у нас в распоряжении две вложенных функции от одного аргумента: 
const getAverageSalary = job => country => /* body */
const salary1 = getAverageSalary('programmer')('spain');
const salary2 = getAverageSalary('programmer')('russia');
const salary3 = getAverageSalary('programmer')('usa');

Попробуем частично применить:

const getProgrammersSalaryByCountry = getAverageSalary('programmer');

const salary1 = getProgrammersSalaryByCountry('spain');
const salary2 = getProgrammersSalaryByCountry('russia');
const salary3 = getProgrammersSalaryByCountry('usa');

В функкциональных языках каррирование используется постоянно
В императивных языках реже, но JS близок к функциональным

Каррирование используется в различных библиотеках и иногда является их ключевой "фичей"



















