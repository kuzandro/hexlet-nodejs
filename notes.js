p {
  color: red;
  font-size: 20px;
}

1.	Первая часть — это селектор (selector). Им мы выбираем то, к чему применять стиль.
2.	Набор стилей указан после селектора в фигурных ({, }) скобках.
3.	Набор состоит из пар свойство: значение (property: value).
Изначально стоит использовать в названиях классов семантический смысл, а не особенность реализации. 
Для уникальных «разовых» элементов стоит использовать id
по правилам (спецификации HTML) элемент с идентификатором должен быть уникальным на странице. То есть нет необходимости выбирать именно h1, достаточно сделать так:
#article-title {
  font-family: Georgia, serif;
  color: #1050ff;
}

Такой элемент будет одновременно красным, размером 20 пикселей и курсивом. Но у разных видов селекторов разный приоритет.
Порядок таков:
1.	Селектор типа элемента (p)
2.	Селектор класса (.dance)
3.	Селектор id (#hue)
1 — низкий приоритет, 3 — высокий приоритет.
•	display: block начинается с новой строки и занимает всю ширину
•	display: inline начинается в любом месте и занимает столько ширины, сколько нужно для помещения содержания
Разные браузеры могут задавать разные стили по умолчанию, и иногда эти стили могут отличаться. Поэтому одна и та же страница может выглядеть по-разному в разных браузерах. Это в основном касается размеров и отступов. Для решения этой проблемы существуют так называемые CSS Reset'ы: наборы CSS-стилей, которые «сбрасывают» браузерные стили.
•	div — это block-level элемент, у него свойство display: block.
•	span — это inline-level элемент, у него свойство display: inline.
Мы использовали значение inline-block у свойства display. Это в какой-то степени комбинация inline и block. Элемент не занимает всю ширину и может находится на одной строке с другими элементами. При этом у него можно задать параметры, свойственные block'у: конкретную ширину и высоту.

Правило близости: объекты, расположенные близко друг к другу, воспринимаются связанно. Из этого правила можно вывести более практическую форму: внутренние расстояния элемента должны быть меньше внешних.

Когда Фейсбук стал не просто популярным сайтом, а по-настоящему глобальной социальной сетью, компания решила создать специальный формат разметки, чтобы веб-мастеры могли чётко задать информацию для вывода в ленте Фейсбука. Этот формат называется OpenGraph, и его распознают не только Facebook, но и ВКонтакте, Twitter, LinkedIn и Google+. http://ogp.me/#types
OpenGraph-теги (или og-теги) — это специальные параметры для стандартного элемента meta, который размещается внутри head.
Теги типа article, nav, footer нужны для того, чтобы поисковые роботы могли семантически анализировать страницу. 
(schema markup и ceо посмотреть) Некоторые социальные сети также имеют собственные особенности или форматы для метаинформации. Вы можете найти их по запросу вроде "linkedin meta tags".
Компьютер и языки программирования
У языка программирования есть два аспекта:
- синтаксис (правила написание кода, правописание, порядок слов)
- семантика (идея, смысловая нагрузка)
Некоторые языки программирования имеют похожий синтаксис, некоторые экзотический. Семантику сложно увидеть, она неявная. В современных языках хороший код означает легко понятную семантику. Если понять то, что делает код, сложно, то код не слишком хороший. Синтаксис легко изучить, его необходимо знать, но этого недостаточно. Не так важно с какого языка начать. Это не как выбор языка на котором говорить, а как выбор инструмента, которым писать – ручка, компьютер, кисть.
Версии JS
JavaScript, как и все остальные языки, не стоит на месте. Примерно каждый год выходит новая версия языка, обладающая новыми возможностями. Использовать эти новые возможности сразу после их выхода — нельзя. Это связано с тем, что сам стандарт и его реализация — это две разные вещи. До внедрения этих возможностей в разные среды исполнения (браузеры, nodejs) должно пройти какое-то время.
Выходом из этой ситуации стал Babeljs. Это специальная программа, которая берет исходный код на современном стандарте JS и превращает его в JS-код более старого формата. Такой трюк позволяет начать использовать все самое вкусное уже прямо сейчас, не дожидаясь полноценной поддержки.
Babeljs фактически стал стандартом де-факто и уже сложно представить, чтобы проекты на js делались без него. Это одна из главных причин, почему на Хекслете преподается последний стандарт js.
Другая причина заключается в том, что новый синтаксис стал гораздо более лаконичным и подчеркивающим правильные идеи программирования. Особенно это станет заметно (хотя, для многих и непривычно) в последующих курсах.
Стиль
Как и при работе с естественными языками, код нужно оформлять определенным образом для того, чтобы он был более понятным и простым в поддержке. Конкретно в js самым распространенным стандартом является https://github.com/airbnb/javascript Он был написан программистами компании airbnb и теперь используется повсеместно. Периодически просматривайте его и улучшайте свой код. Следование стандартам не только входит в практики экстремального программирования, но и является неотъемлемой частью при работе в команде.
В любом языке программирования существуют специальные инструменты, так называемые линтеры, задачей которых является проверка кода на соответствие стандартам. В js это eslint.

Способы записи функций

//const <name> = (<argument>) => {
//	return <expressions>;
//};

const identity = (value) => {
	return value;
};

Для однострочных функций
// const <name> = (<argument>) => <expressions>;
const identity = value => value;

Используя ключевое слово function. Это устаревший вариант, есть семантическое отличие

const identity = function(value) {
	return value;
};

Такую функцию можно использовать до ее определения в этом файле

function identity(value) {
  return value;
}

Формальные параметры функции - имена переменных в определении функции.
Фактические параметры функции - то, что было передано в функцию в момент вызова.
Между их именами нет связи, у фактических может вообще не быть имен. Важен только одинаковый порядок.

После слова return функция не выполняется

Условия

Пример записи условий

const (abs) = (num) => {
	if (num > 0) {
		return num;
	} else if (num < 0) {
		return -num;
	} else {
		return 0;
	}
}

Предикат - то, что дает true или false
=== !== > < >= <=

AND (&&) OR (||) NOT (!) 
XOR - это OR без 1 1 = 1

Сокращенная версия if - тернарный оператор

condition ? expression : expression

const absValue = (num === 0 || num > 0) ? num : -num;

Только два варианта -  один для тру, один для фолс
Тернарная операция вычисляется и возвращает значение, те это выражение
Условная конструкция if в js не является выражением. 
Это инструкция, она выполняет действие - не вычисляя и не возврщая.
Не можем присвоить константе значние if и тд

Функция  однострочник с тернарным оператором
const getAbs = num => (num >= 0) ? num : -num;
 - вложенные тернарники ухудшают читаемость кода
 - тернарник не подходит для выполнения блоков кода
 - инструкцию return нельзя использовать внутри тернарного оператора

 Виды ошибок

 Syntax Error - неверное использование языка, часто незакрытые скобки или кавычки.
 Reference Error - использование несуществующего названия. Проверить существование того, на что ссылаешься
 Type Error - использование неверного типа (напр константа как функция). Часто путаница в именах.
 Logic Error - ошибки не вылзают, но код делает не то, что должен. Сломалась логика, проверить, что делает код.

 Самый действенный способ понять, как работает участок кода — это расписать его выполнение на бумажке, как если бы вы были компьютером 
 
Метод утёнка — психологический метод решения задачи, делегирующий её мысленному помощнику. 
Метод описан в книге «Программист-прагматик».

Тестируемый ставит на рабочем столе игрушечного утёнка (или представляет его мысленно; 
на самом деле уточка - это условно, предмет может быть любым), 
и когда у него возникает вопрос, на который трудно ответить, 
то он задаёт его игрушке, как живому человеку, словно она действительно может ответить.

Считается, что правильная формулировка вопроса содержит как минимум половину ответа, 
а также это дает толчок мыслям, направляя их в нужное русло.

Метод также используется при отладке. 
Если определённая часть программы не работает, программист пытается объяснить утёнку, 
что делает каждая строка программы, и в процессе этого сам находит ошибку.

Рекурсия

Определение функции - это описание коробки.
Оригинал коробки формируется при вызове функции.
Когда функция вызывает сама себя, создается новая идентичная коробка.

Перестановки и факториал
Количество способов перестановки n объектов - т!
n! определяется таким способом - если n = 1, то n! = 1; если n>0, то n! = n*(n-1)!

const factorial = (n) => {
	if (n === 1) {
		return 1;
	}
	else{
		return n * factorial(n-1);
	}
}

const answer = factorial(3);

Требования рекурсии:
1. Простой базовый случай (когда остановиться)
2. Правило углубления

В факториале ничего не умножается, пока не дойдем до базового случая.
Дальше поднимаемся обратно и умножаем.

0! = 1, а простой базовый случай для n! это 0!

Итеративный процесс
Рекурсия - абстрактная концепция содержания самого себя в своем описании
Рекурсивный процесс - откладываение вычислений до самого конца.
Вся информация о вычислениях в конкретный момент называется состоянием.
Во время рекурсивного процесса создается множество состояний - потому
что функции вызываются по очереди и не закрываются, пока процесс не пойдет в обратном
порядке.
Суть итеративного процесса - вычисление с фиксированным количеством состояний.
Вычисления производятся по чуть чуть на каждом шаге.

const factorial = (n) => {
	const iter = (counter, acc) => {
		if (counter = 1) {
			return acc;
		}
		return iter(counter - 1, counter * acc);
	};

	return iter(n, 1);
}

1. Считаем от n до 1
2. Берем число из предыдущего шага
3. Умножаем это число на текущее число
4. Передаем его в новый шаг
5. Конгда conter достигает 1, число передается из предыдущего шага в ответ
Так как нужно с чего то начинать, в начале acc равно 1, и counter*1 = counter

Итеративынй процесс в целом: 
Определить начальное состояние. В нашем случае мы делаем первый вызов iter с n и 
1. Это начальное состояние.
​2. Проверить терминальный сценарий. Мы убеждаемся, что counter это 1 и останавливаем рекурсию, когда он достигает значения 1.
​3. Определить новое состояние. Это то, как продвигается процесс. В нашем случае мы делаем ещё один вызов iter с уменьшенным counter и умноженным accumulator. Два этих новых числа определяют новое состояние.
4. Повторить шаг 2.​

Рекурсия — это когда что-то содержит себя в своём описании.
Рекурсивный процесс — это процесс обработки данных с отложенными вычислениями.
Итеративный процесс — это процесс вычисления, когда состояние может быть описано фиксированным количеством значений.

Декларативное и императивное программирование
Два варианта факториала
const recursiveFactorial = (n) => {
  if (n === 1) {
    return 1;
  }
  return n * recursiveFactorial(n-1);
}
Эта рекурсиваная функция - декларативная.
Она как бы определение (трактование, характеристика) факториала.
Она декларирует, что такое факториал.
От латинского "clarare" — разъяснять, заявлять, делать объявление. 
Вы разъясняете: я хочу, чтобы факториал n был n раз факториалом n-1.

const factorial = (n) => {
  let counter = 1;
  let result  = 1;

  while (counter <= n) {
    result = result * counter;
    counter = counter + 1;
  }

  return result;
}
Эта нерекурсивная итеративная функция — императивная — описание того, что нужно делать, чтобы найти факториал.
От латинского "imperare", что значит "командовать". Вы приказываете чётко передвигаться по шагам — умножать это на это, пока идёт отсчёт и запоминаются какие-то числа.
Декларативное — это что. Императивное — это как.
Переменные, циклы и изменение состояния - этопро императивное программирование.

Писать декларативный код лучше, он более понятный, но не всегда есть выбор.
От изменения состояния появляются бага, а операторы присваивания - это часто зло.
Когда дело доходит до инструкций присваивания, стоит действовать осторожно.

let - более современный и правильный вариант var
let и var по разному влияют на видимость переменной, и использование var сегодня не желательно. let был создан как более правильная альтернатива старому способу.


Строки

Строка - последовательность символов. Создание строк
const str1 = "Hello";
const str2 = 'Hello';

Использование ковычек внутри Строки
const str1 = 'They call him "Harry", and he likes it';
const str2 = "They call him 'Harry', and he likes it";

Если одного типа кавычки, то они экранируются
const str1 = 'They call her \'Ann\', and she likes it';
const str2 = "They call her \"Ann\", and she likes it";
Другие примеры экранирования
const str = "This is a backslash \\ here"
// This is a backslash \ here
Управляющие символы
const str = "There is a tab \t and here \ncomes the new line!"

// Here is a tab    and here
// comes the new line!

Склеивание строк - конкатенация +
const name = "Alex";
const age = 22;
console.log("His name is " + name + " and his age is " + age);

// His name is Alex and his age is 22
 доступ по индексу - str[i] это i-ый символ строки str, начинающейся с 0

 В JS строки неизменяемы, все функции, меняющие строку, возвращают новую строку, а не
 производят inplace замены. Это верно и в том случае, когда мы обращаемся к конкретному символу в строке.

 Можно сравнивать строки < >. Сравнение будет лексикографическим ( в алфавитном порядке).

Интерполяция строк. 
Обратные тики (backticks): ``
Интерполяция предпочтительнее конкатенации
Мы советуем не использовать конкатенацию вообще. Вот некоторые из причин:
- Такой код заставляет больше думать, потому что синтаксически + больше смахивает на сложение.
- Из-за слабой типизации можно легко получить не тот результат. Конкатенация может породить ошибки.
- Сложные строки при использовании конкатенации невозможно нормально разобрать в голове и понять, как они устроены.

const name = "Alex";
const a = 10;
const b = 12;
console.log(`His name was ${name} and his age was ${a + b}`);